/* eslint-disable @typescript-eslint/no-unused-vars */
import {
  Entity,
  PrimaryGeneratedColumn,
  PrimaryColumn,
  Column,
  OneToMany,
  ManyToOne,
  ManyToMany,
  OneToOne,
  JoinTable,
  JoinColumn,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn
} from 'typeorm';
import { Exclude } from 'class-transformer';
import {User} from "../../user/entities/user.entity";


<%
  const importedRelations = new Set();
%>
<% fields.forEach(field => { %>
  <% if (field.relation && field.relation.target !== 'User' && !importedRelations.has(field.relation.target)) { 
       const relationFile = field.relation.target.toLowerCase();
       importedRelations.add(field.relation.target);
  %>
import { <%= field.relation.target %> } from "../../<%= relationFile %>/entities/<%= relationFile %>.entity";
  <% } %>
<% }) %>

@Entity()
export class <%= name %> {

  <% if (primaryFields) {%>
    <% if (primaryFields.length === 1) {%>
  
      <% if (primaryFields[0].dtype === 'uuid') { %>
        @PrimaryColumn({ type: 'char', length: '36', name: '<%= primaryFields[0].dbName || snakeCase(primaryFields[0].name) %>' ,default: () => 'UUID()' })
      <% } else { %>
          @PrimaryGeneratedColumn({ type: 
            <% if (primaryFields[0].dtype) { %>'<%= primaryFields[0].dtype %>'
            <% } else{ %>'bigint' <% } %>,
            <% if (primaryFields[0].dbName) { %>name: '<%= primaryFields[0].dbName %>',
            <% } else{ %>name: '<%= snakeCase(primaryFields[0].name)%>' <% } %>
          })
      <% } %>
        <%= primaryFields[0].name %>: <% if (primaryFields[0].type) { %><%= primaryFields[0].type %>
        <% } else{ %>string <% } %>;
     
    <% } else { %>
          <% primaryFields.forEach(primaryField => { %>
            @PrimaryColumn({ type: 
              <% if (primaryField.dtype === 'uuid') { %>
                'char',
                length: '36' 
              <% } else{ %>'<%= primaryFields[0].dtype || "bigint" %>' <% } %>,
              <% if (primaryField.dbName) { %>name: '<%= primaryField.dbName %>',
              <% } else{ %>name: '<%=snakeCase( primaryField.name )%>' <% } %>
            })
            <%= primaryField.name %> : <% if (primaryField.type) { %><%= primaryField.type %>
              <% } else{ %>string <% } %>;
          <% }) %>
    <% } %>
  <% } else { %>
      @PrimaryGeneratedColumn({ type: 'bigint', name: 'id' })
      id: string;
  <% } %>
<% fields.forEach(field => { %>
  <% if (field.relation) {%>
    <% let targetLower =field.relation.target.toLowerCase(); %>
    <% let generatedInverse =name.toLowerCase()+field.name.charAt(0).toUpperCase() + field.name.slice(1); %>
    @<%= field.relation.type %>(
      () => <%= field.relation.target %><% if (field.relation.inverseSide) { %>, (<%= targetLower %>) => <%= targetLower %>.<%= field.relation.inverseSide %>
        <% } else if(!field.relation.uniDirectional){ %>
            , (<%= targetLower %>) => <%= targetLower %>.<%= generatedInverse %>
        <% } %>
   ,{
      
      <% if (['OneToOne', 'ManyToOne'].includes(field.relation.type)) { %> 
        cascade: <%= field.relation.cascade ?? false%>, 
        onUpdate: '<%- field.relation.onUpdate ?? 'CASCADE'%>',
        onDelete: '<%- field.relation.onDelete ?? 'SET NULL'%>',
       <% if (field.relation.nullable !== undefined) { %>nullable: <%= field.relation.nullable %>,<% } %>
      <% } %> 
      <% if (field.relation.type === 'ManyToMany') { %>
      cascade: <%= field.relation.cascade ?? false%>, 
      <% } %>
    } 
  )
    <% if (field.relation.type === 'ManyToMany') { %>  
     
      @JoinTable(<%- field.relation.joinTable ? JSON.stringify(field.relation.joinTable, null, 2) : '' %>)
      <%= field.name %>: <%- field.relation.isArray ? `${field.relation.target}[]` : `${field.relation.target}` %>;
<% } else if (['OneToOne', 'ManyToOne'].includes(field.relation.type)) { %>
  @JoinColumn(
        <% if (field.relation.joinColumn) { %>
          <%- JSON.stringify(field.relation.joinColumn, null, 2) %>
        <% } else {%>{ name:'<%= field.relation.joinColumn?.name ||  snakeCase(field.name)+'_id' %>' }
        <%}%>
      )
  <%= field.name %>: <%- field.relation.isArray ? `${field.relation.target}[]` : `${field.relation.target}` %>;

  @Column({ name:'<%= field.relation.joinColumn?.name ||  snakeCase(field.name)+'_id' %>', type: 'bigint', nullable: true })
  <%= field.name %>Id?: string;
<% } else if (field.relation.type === 'OneToMany') { %>
  <%= field.name %>: <%- field.relation.isArray ? `${field.relation.target}[]` : `${field.relation.target}` %>;
<% } %>
    

  
  <% } else { %>
    @Column({
      <% if (field.type) { %>type: '<%= field.dtype %>',<% } %>
      <% if (field.enum) { %>enum: <%- JSON.stringify(field.enum) %>,<% } %>
      <% if (field.dbName) { %>name: '<%= field.dbName %>',<% } else{ %>name: '<%= snakeCase(field.name) %>' <% } %>,
      <% if (field.length || field.type==='varchar') { %>length: <%= field.length || 255 %>,<% } %>
      <% if (field.nullable !== undefined) { %>nullable: <%= field.nullable %>,<% } %>
      <% if (field.unique) { %>unique: true,<% } %>
      <% if (field.default !== undefined) { %>default: <%- JSON.stringify(field.default) %>,<% } %>
    })
    <%= field.name %>:
    <% if (field.enum) { %><%- field.enum.map(v => `'${v}'`).join(' | ') %>
    <% } else { %>
      <%= field.type || field.dtype %>;
     <% } %>
  <% } %>
  
<% }) %>

<% if (creationConfig?.withTimestamps) { %>
  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;
<% } %>

<% if (creationConfig?.withSoftDelete) { %>
  @Exclude()
  @DeleteDateColumn({ name: 'deleted_at' })
  deletedAt: Date;
<% } %>

<% if (creationConfig?.operator) { %>

    @ManyToOne(() => User, {
      cascade: true,
      onUpdate: 'CASCADE',
      onDelete: 'SET NULL',
      nullable: true,
    })
    @JoinColumn({ name: 'created_by' })
    createdBy?: User;

    @ManyToOne(() => User, {
      cascade: true,
      onUpdate: 'CASCADE',
      onDelete: 'SET NULL',
      nullable: true,
    })
    @JoinColumn({ name: 'updated_by' })
    updatedBy?: User;


  

  <% if (creationConfig?.withSoftDelete) { %>
    @Exclude()
    @ManyToOne(() => User, {
      cascade: true,
      onUpdate: 'CASCADE',
      onDelete: 'SET NULL',
      nullable: true,
    })
    @JoinColumn({ name: 'deleted_by' })
    deletedBy?: User;
    <% } %>
<% } %>



  static selectFields = {
    id: true,
<% fields.forEach(field => { if (!field.relation) { %>    <%= field.name %>: true,
<% }}) %>
<% if (creationConfig) { %>
<% if (creationConfig.withTimestamps) { %>    createdAt: true,
    updatedAt: true,
<% } %>
<% if (creationConfig.operator) { %>    createdBy: true,
    updatedBy: true,
<% if (creationConfig.withSoftDelete) { %>    // deletedAt is excluded (excluded by @Exclude())
<% } } %>
  } as const;

  static relationalFields = {
<% fields.forEach(field => { if (field.relation) { %>    <%= field.name %>: true,
<% }}) %>
<% if (creationConfig.operator) { %>    createdBy: true,
    updatedBy: true,
<% if (creationConfig.withSoftDelete) { %>    deletedBy: true,
<% } } %>
  } as const;
<% } %>


}
