/* eslint-disable @typescript-eslint/no-unused-vars */
import {
    Injectable,
    BadRequestException,
    InternalServerErrorException,
  } from '@nestjs/common';
  import { InjectRepository } from '@nestjs/typeorm';
  import { Repository, In, Not,FindOptionsWhere } from 'typeorm';
  
  import { GlobalService } from '../../utils/global/global.service';
  import { <%= entityName %> } from './entities/<%= entityFileName %>.entity';
  import {
    PaginationResDto,
    ServiceResDto,
    TypeOrmDeleteResult,
  } from '../../utils/global/dto/global.dto';
  import {
    <%= entityName %>FullBodyReqDto,
    <% if(primaryFields?.length>1) { %>
      PrimaryKeys<%= className %>Dto,
      <% } else { %>
        FindOne<%= className %>ParamReqDto,
      <% } %>
    Create<%= entityName %>BodyReqDto,
    Update<%= entityName %>BodyReqDto,
    UpdateAndDelete<%= className %>BodyReqDto
  } from './dto/<%= entityFileName %>.dto';
  import { ModelService } from '../../utils/model/model.service';
  import { DeleteRollBackDto } from '../../utils/model/model.dto';
  import { CustomLogger } from 'src/utils/logger/logger.service';
  <% if(creationConfig.operator) {%>
    import { User } from '../user/entities/user.entity';
  <% } %>


  

  @Injectable()
  export class <%= entityName %>Service {
    constructor(
      @InjectRepository(<%= entityName %>)
      private <%= entityVar %>Repository: Repository<<%= entityName %>>,
      private globalService: GlobalService,
      private modelService: ModelService,
      private readonly customLogger: CustomLogger,
    ) {}
  
    async findMany(
      where: FindOptionsWhere<<%= entityName %>>  = {},
      page: number,
      limit: number,
    ): Promise<ServiceResDto<<%= entityName %>[]>> {try{
      const skipRecord = this.globalService.getSkipRecord(page, limit);
      const [dataArray, dataCount] = await this.<%= entityVar %>Repository.findAndCount({
        where,
        take: limit,
        skip: skipRecord,
      });
      const paginationData = this.globalService.setPagination(page, limit, dataCount);
      return {
        data: dataArray,
        pagination: paginationData,
      };}catch (error) {
        this.customLogger.error('Error while finding roles::', error.stack);
        throw new InternalServerErrorException(error);
      }
    }
  
    async create(
      createDto:Create<%= entityName %>BodyReqDto,
      <% if(creationConfig.operator) {%>
        createdByUser: User,
      <% } %>
      
    ): Promise<<%= entityName %>> {
      
  
      const createEntity: <%= entityName %> = this.<%= entityVar %>Repository.create({
        ...createDto,
        <% if(creationConfig.operator) {%>
        createdBy: createdByUser,
        updatedBy: createdByUser,
        <% } %>
      });
      const saveEntity: <%= entityName %> = await this.<%= entityVar %>Repository.save(createEntity);
      if (!saveEntity) {
        throw new BadRequestException('Fail to create');
      }
      return this.modelService.removeUserBy(saveEntity);
    }
  
    async findOne(primaryKeyFields:<% if(primaryFields?.length>1) { %>
      PrimaryKeys<%= className %>Dto,
      <% } else { %>
        FindOne<%= className %>ParamReqDto,
      <% } %>): Promise<<%= entityName %>> {
        const metadata = this.<%= entityVar %>Repository.metadata;
        const allRelations = metadata.relations.map((rel) => rel.propertyName);
      const data = await this.<%= entityVar %>Repository.findOne({
        where: { 
          <% if (primaryFields) { %>          
            <% primaryFields.forEach(element => { %>
            <%= element.name %>:primaryKeyFields.<%= element.name %>,
          <% }) %>
          <% } else { %>
            id: id
          <% } %>
      },
      relations: allRelations,
      });
      if (!data) throw new BadRequestException('<%= entityName %> not found');
      return data;
    }
  
  
    async update(
      updateDto: UpdateAndDelete<%= className %>BodyReqDto,
      primaryKeyFields:<% if(primaryFields?.length>1) { %>
        PrimaryKeys<%= className %>Dto,
        <% } else { %>
          FindOne<%= className %>ParamReqDto,
        <% } %>
        <% if(creationConfig.operator) {%>
          updatedByUser: User,
        <% } %>
        <% if (creationConfig.softDelete) { %>
      isRollback = false,
      <% } %>
    ): Promise<<%= entityName %>> {
      <% if (creationConfig.softDelete) { %>
      const rollbackObj: DeleteRollBackDto = isRollback ? { withDeleted: true } : {};
      <% } %>
      let entity = await this.<%= entityVar %>Repository.findOne({
        where: { 
                  <% if (primaryFields) { %>          
                    <% primaryFields.forEach(element => { %>
                    <%= element.name %>:primaryKeyFields.<%= element.name %>,
                  <% }) %>
                  <% } else { %>
                    id: id
                  <% } %>
              },
              <% if (creationConfig.softDelete) { %>
        ...rollbackObj,
        <% } %>
      });
      if (!entity) throw new BadRequestException('<%= entityName %> not found');
  
      entity = this.modelService.updateModelValue(entity, updateDto, <% if(creationConfig.operator) {%>
        updatedByUser,
      <% } %>);
  
      return await this.<%= entityVar %>Repository.save(entity);
    }
  
    async delete(primaryKeyFields:<% if(primaryFields?.length>1) { %>
      PrimaryKeys<%= className %>Dto,
      <% } else { %>
        FindOne<%= className %>ParamReqDto,
      <% } %>): Promise<boolean> {
      const data = await this.<%= entityVar %>Repository.findOne({
        where: { 
          <% if (primaryFields) { %>          
            <% primaryFields.forEach(element => { %>
            <%= element.name %>:primaryKeyFields.<%= element.name %>,
          <% }) %>
          <% } else { %>
            id: id
          <% } %>
      },
        withDeleted: true,
      });
  
      if (!data) throw new BadRequestException('<%= entityName %> not exists');
      <% if (creationConfig.softDelete) { %>
      if (!data.deletedAt) throw new BadRequestException('Only soft-deleted records can be deleted');
      <% } %>
      const result = await this.<%= entityVar %>Repository.delete(primaryKeyFields);
      return result.affected ? true : false;
    }
  }
  