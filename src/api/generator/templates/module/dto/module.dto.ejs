/* eslint-disable @typescript-eslint/no-unused-vars */
import {
    IsNotEmpty,
    MaxLength,
    IsString,
    IsBoolean,
    IsOptional,
    IsArray,
    IsInt,
    IsIn,
    Matches ,
    IsUUID ,
  } from 'class-validator';
  import { Transform, Type } from 'class-transformer'; 
  import { IntersectionType } from '@nestjs/mapped-types';
  export class <%= className %>FullBodyReqDto {
    @IsString()
    @IsOptional()
    @MaxLength(20)
    name?: string;
  
    @IsString()
    @IsOptional()
    description?: string;
  
    @IsBoolean()
    @IsOptional()
    isAdmin?: boolean;
  
    @IsBoolean()
    @IsOptional()
    hasPublished?: boolean;
  
    @IsBoolean()
    @IsOptional()
    hasSoftDeleted?: boolean;
  }
  
  export class FindMany<%= className %>QueryReq {
    @IsInt()
    @Transform(({ value }) => Number.parseInt(value))
    page: number;
  
    @IsInt()
    @Transform(({ value }) => Number.parseInt(value))
    limit: number;
  }
  
  
  <%  if (primaryFields && primaryFields.length > 1) { %>
    export class PrimaryKeys<%= className %>Dto {
      <% primaryFields.forEach(field => { %>
        <% if (field.dtype === 'uuid') { %>
          @IsUUID()
          <% } else if ( field.dtype === 'int') { %>
            @Type(() => Number)
            @IsInt()
          <% } else { %>
            @IsString()
            @Matches(/^\d+$/, { message: 'ID must be a string of digits' })
          <% } %>
          @IsNotEmpty()
          <%= field.name %>: <%= field.tsType || field.type || 'string' %>;
      <% }) %>
    }
  <% } else { %>
    export class FindOne<%= className %>ParamReqDto {
      <% if (primaryFields && primaryFields.length === 1) { %>
        <% if (primaryFields[0].dtype === 'uuid') { %>
          @IsUUID()
        <% } else if (primaryFields[0].dtype === 'int') { %>
          @Type(() => Number)
          @IsInt()
        <% } else { %>
          @IsString()
            @Matches(/^\d+$/, { message: 'ID must be a string of digits' })
        <% } %>
        @IsNotEmpty()
        <%= primaryFields[0].name %>: <%= primaryFields[0].tsType || primaryFields[0].type || 'string' %>;
        <% } else { %>
          @IsString()
          @Matches(/^\d+$/, { message: 'ID must be a string of digits' })
          @IsNotEmpty()
          id: string;
        <% } %>
    }
  <% } %>
  export class Create<%= className %>BodyReqDto 
    <%  if (primaryFields && primaryFields.length > 1) { %> 
      extends  PrimaryKeys<%= className %>Dto
    <% } %>
  {
    <% fields.forEach(field => { %>
      <% if (field.apiProperty) { %>
      @ApiProperty()
      <% } %>
    
      <% if (field.relation) { %>
        <% if (['OneToOne', 'ManyToOne'].includes(field.relation.type)) { %> 
          @IsOptional()
          @IsString()
          <%= field.name %>Id?: string;
        <% } else { %>
          @IsOptional()
          @IsArray()
          @IsString({ each: true })
          <%= pluralize.singular(field.name) %>Ids?: string[];
        <% } %>
    
      <% } else { %>
        <% if (field.type === 'string') { %>
        @IsString()
        <% } else if (field.type === 'boolean') { %>
        @IsBoolean()
        <% } else if (field.type === 'number' || field.type === 'int') { %>
        @IsInt()
        <% } else if (field.type === 'array') { %>
        @IsArray()

        <% } else { %>
        @IsNotEmpty()
        <% } %>
    
        <% if (field.maxLength) { %>
        @MaxLength(<%= field.maxLength %>)
        <% } %>
       
    
        <% if (!field.nullable) { %>
          @IsOptional()
          <% if (field.enum) { %>
            @IsIn(<%- JSON.stringify(field.enum) %>)
            <%= field.name %>?: <%- field.enum.map(v => `'${v}'`).join(' | ') %>;
          <% } else { %>
              <%= field.name %>?: <%= field.tsType || field.type %>;
          <% } %>
        <% } else { %>
          <% if (field.enum) { %>
            @IsIn(<%- JSON.stringify(field.enum) %>)
            <%= field.name %>: <%- field.enum.map(v => `'${v}'`).join(' | ') %>;
          <% } else { %>
              <%= field.name %>: <%= field.tsType || field.type %>;
          <% } %>          
        <% } %>
      <% } %>
    <% }) %>
      
  }
  
  export class Update<%= className %>BodyReqDto {
    <% fields.forEach(field => { %>
      <% if (field.apiProperty) { %>
      @ApiProperty()
      <% } %>
    
      <% if (field.relation) { %>
        <% if (['OneToOne', 'ManyToOne'].includes(field.relation.type)) { %> 
          @IsOptional()
          @IsString()
          <%= field.name %>Id?: string;
        <% } else { %>
          @IsOptional()
          @IsArray()
          @IsString({ each: true })
          <%= pluralize.singular(field.name) %>Ids?: string[];
        <% } %>
    
      <% } else { %>
        <% if (field.type === 'string') { %>
        @IsString()
        <% } else if (field.type === 'boolean') { %>
        @IsBoolean()
        <% } else if (field.type === 'number' || field.type === 'int') { %>
        @IsInt()
        <% } else if (field.type === 'array') { %>
        @IsArray()
    
    

 
        <% } else { %>
        @IsNotEmpty()
        <% } %>
    
        <% if (field.maxLength) { %>
        @MaxLength(<%= field.maxLength %>)
        <% } %>
        @IsOptional()
        <%= field.name %>?: <%= field.tsType || field.type %>;
      <% } %>
    <% }) %>
  }
  
  export class Delete<%= className %>BodyReqDto {
    @IsBoolean()
    @IsOptional()
    hasSoftDeleted?: boolean;
  }
  
  export class UpdateAndDelete<%= className %>BodyReqDto extends IntersectionType(
    Update<%= className %>BodyReqDto,
    Delete<%= className %>BodyReqDto,
  ) {}
  